import uuid

from django.conf import settings
from django.db import models


def audio_upload_path(instance, filename):
    """Organise uploads by user ID to avoid filename collisions."""
    return f"audio/{instance.user.id}/{uuid.uuid4()}/{filename}"


class Encounter(models.Model):
    """
    Top-level record for a single doctor-patient consultation.
    Tracks the processing pipeline from PENDING → COMPLETED (or FAILED).
    """

    class Status(models.TextChoices):
        PENDING = "PENDING", "Pending"
        TRANSCRIBED = "TRANSCRIBED", "Transcribed"
        REDACTED = "REDACTED", "Redacted"
        COMPLETED = "COMPLETED", "Completed"
        FAILED = "FAILED", "Failed"

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="encounters",
    )
    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        db_index=True,
    )
    audio_file = models.FileField(upload_to=audio_upload_path)
    original_filename = models.CharField(max_length=255)
    error_message = models.TextField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"Encounter {self.id} [{self.status}]"


class Transcript(models.Model):
    """
    Raw and PII-redacted transcript for an Encounter.
    raw_text contains DOCTOR:/PATIENT: speaker labels from AssemblyAI.
    redacted_text has all PII replaced with placeholder tags by Presidio.
    """

    encounter = models.OneToOneField(
        Encounter,
        on_delete=models.CASCADE,
        related_name="transcript",
    )
    raw_text = models.TextField()
    redacted_text = models.TextField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Transcript → {self.encounter.id}"


class SOAPNote(models.Model):
    """
    Structured SOAP note generated by Groq (Llama 3.3 70B)
    from the PII-redacted transcript.
    """

    encounter = models.OneToOneField(
        Encounter,
        on_delete=models.CASCADE,
        related_name="soap_note",
    )
    subjective = models.TextField()
    objective = models.TextField()
    assessment = models.TextField()
    plan = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"SOAP Note → {self.encounter.id}"


class QualityMetric(models.Model):
    """
    Internal accuracy metrics for each processed encounter.
    Admin-only — never exposed to users via the API or templates.

    Transcription metrics (from AssemblyAI word-level confidence):
      - transcript_confidence: average word confidence score (0.0 – 1.0)
      - transcript_word_count: number of words in the raw transcript

    SOAP metrics:
      - soap_sections_complete: how many of the 4 SOAP sections contain
        substantive content (i.e. not the "Not documented" fallback) — 0 to 4
      - groq_prompt_tokens: tokens sent to Groq
      - groq_completion_tokens: tokens returned by Groq
      - groq_model: model name used for generation
    """

    _NOT_DOCUMENTED = "Not documented in this consultation."

    encounter = models.OneToOneField(
        Encounter,
        on_delete=models.CASCADE,
        related_name="quality_metric",
    )

    # ── Transcription ─────────────────────────────────────────────────────────
    transcript_confidence = models.FloatField(
        null=True, blank=True,
        help_text="Average AssemblyAI word-level confidence (0.0 – 1.0).",
    )
    transcript_word_count = models.IntegerField(
        null=True, blank=True,
        help_text="Total word count in the raw transcript.",
    )

    # ── SOAP generation ───────────────────────────────────────────────────────
    soap_sections_complete = models.IntegerField(
        null=True, blank=True,
        help_text="Number of SOAP sections with substantive content (0 – 4).",
    )
    groq_prompt_tokens = models.IntegerField(null=True, blank=True)
    groq_completion_tokens = models.IntegerField(null=True, blank=True)
    groq_model = models.CharField(max_length=100, blank=True, default="")

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Quality Metric"
        verbose_name_plural = "Quality Metrics"

    def __str__(self):
        return f"QualityMetric → {self.encounter.id}"

    @property
    def confidence_pct(self):
        if self.transcript_confidence is not None:
            return f"{self.transcript_confidence * 100:.1f}%"
        return "N/A"

    @property
    def soap_completeness_pct(self):
        if self.soap_sections_complete is not None:
            return f"{self.soap_sections_complete}/4 sections"
        return "N/A"
